
Log handler
============

Задача
------
Даны два файла. В одном (in.csv) записи вида
- 94217450,omicron,six
- 257378401,kapa,six

В другом (source.dat) строки вида
- 9421745055475581812937209119620473391368377353347043
- 257378401301914146320639397939481408524323198549112

Первое поле записи первого файла (94217450) может являться началом записи второго:
- 9421745055475581812937209119620473391368377353347043

Необходимо сформировать третий файл, который будет содержать запись из второго файла и
второе и третье поля записи первого файла, первое поле которой является началом записи
второго файла:

- 257378401,kapa,six =>
257378401301914146320639397939481408524323198549112

Запись выходного файла:
- 257378401301914146320639397939481408524323198549112 => kapa,six

Нужно иметь в виду, что первое поле записи первого файла может оканчиваться на ноль
(94217450), и может присутствовать другая запись с таким же полем, но с дополнительной
цифрой после нуля (942174505). В этом случае надо использовать поле, оканчивающееся
на отличную от нуля цифру (то есть использовать не 94217450, а 942174505)



Описание алгоритма
------------------
Согласно условию задачи, у нас есть исходный файл source.csv, который содержит
записи из трех столбцов. Первый столбец каждой записи содержит строку с
некоторым числом. Исследование исходного файла показало, что строки в первом
столбце имеют разную длину. Строки меньшей длины не имеют одного символа (в данном
случае это '0'), а строки большей содержат добавочный символ (в данном случае любой
из алфавита {1, ..., 9}). К примеру, строке длиной 8 символов '94217450' в
файле с данными будет соответствовать строка '94217450079147346718571616727125444131723488',
а строке '942174501' длиной 9 символов -- '9421745011294555868633860630539567004287'
поэтому их необходимо обрабатывать отдельно.

Считаем, что у нас есть строки двух длин.
Длину короткой строки обозначим k, следовательно, длинная строка будет k + n.

Также у нас есть файл с данными data.dat, строки которого начинаются со строк
из первого столбца первого файла.

Прежде всего, необходимо получить длину самой длинной и самой короткой строк
в первом столбце первого файла. Для этого читаем файл source.csv и помещаем
данные в список. Из списка получаем длину наибольшего и наименьшего элемента.
Создаем два словаря, ключами которого будут строки первого столбца первой
записи исходного файла, a значением -- список из 2 и 3 столбца.
Притом один словарь будет с ключами длины k + n, а другой с ключами длины k.

Далее читаем файл с данными, строки помещаем во множество. В цикле проходим
все элементы множества и проверяем, входит ли срез длины k + n со строки
из множества в словарь с ключами длины k + n; если входит, то добавляем в
выходной список. Также найденный элемент множества добавляем в другое множество
out_set. Далее находим разность множества с данными и множества с найденными
элементами. Теперь в цикле проходим все элементы разности двух множеств
и проверяем, входит ли срез длины k со строки из множества в словарь с
ключами длины k; если входит, то добавляем в выходной список.

Из выходного списка записываем файл out.csv

Таким образом можно найти и заменить вхождения строк в исходном файле, если
строки двух длин (k и k + n), на строки во втором файле.

Производительность
------------------
На машине с Core2Duo T7200, с 2 GB памяти и HDD@7200 об. выполнение
скрипта занимает около 0.600 ms (данные утилиты time) и 16 MB памяти
(данные memory_profiler).

Примечание
----------
Я сознательно не использовал сторонней библиотеки для чтения csv
для упрощения кода. Кроме того, в рабочем варианте необходимо отлавливать
исключения, возникающие, если списки пусты (для упрощения я также не стал
добавлять).




